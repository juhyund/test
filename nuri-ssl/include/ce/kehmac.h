#ifndef _KEHMAC_H_
#define _KEHMAC_H_

/** @file kehmac.h
    @ingroup KEA
    @brief HMAC을 이용한 KE 모듈

    Key Exchagne 방식 중 HMAC을 이용한 프로토콜이다.
    AKEP2(Authenticated Key Excahge Protocol2)를 따른다.
    이 방식은 인증과 KDF(key derivation func.)을 위한 각각의 키와 해쉬 함수를 사용한다.
*/

#include "sp_define.h"
#include "asn1.h"
#include "pkcs.h"
#include "hmac.h"

#ifdef __cplusplus
extern "C" {
#endif

#define KEHMAC_NONCE_LEN 16
#define KEHMAC_NONCE_BIT_LEN 128

typedef struct {
  ASNSeqClass klass;
  BitString *bNonce;
} KEHMAC_B_ChalToken;

LIBSPEC_SP
extern ASNDescriptor AD_KEHMAC_B_ChalToken;

typedef struct {
  ASNSeqClass klass;
  OctetString *aName;
  OctetString *bName;
  BitString   *aNonce;
  BitString   *bNonce;
  Digest      *digest; 
} KEHMAC_A_RespToken;

LIBSPEC_SP
extern ASNDescriptor AD_KEHMAC_A_RespToken;

typedef struct {
  ASNSeqClass klass;
  OctetString *bName;
  BitString   *aNonce;
  Digest      *digest;
} KEHMAC_B_RespToken;

LIBSPEC_SP
extern ASNDescriptor AD_KEHMAC_B_RespToken;

/**
    @ingroup KEA
    @brief KEHMAC을 사용하기 위한 정보를 담을 구조체

    MAC용 key와 hash 알고리즘 descriptor는 Response를 만들고 검증하는 
    함수에서 사용하고,
    KDF용 key와 hash 알고리즘 descriptor는 GetKey 함수에서 사용한다.
    
*/    
typedef struct {
  char   aName[80];  /**< A의 실체 이름 */
  char   bName[80];  /**< B의 실체 이름 */
  BYTE   macKey[HMAC_MAX_KEY_LEN]; /**< MAC용 key      */
  BWT    macKeyLen;                /**< MAC용 key 길이 */
  BYTE   kdfKey[HMAC_MAX_KEY_LEN]; /**< KDF용 key      */
  BWT    kdfKeyLen;                /**< KDF용 key 길이 */
  BYTE   aNonce[KEHMAC_NONCE_LEN]; /**< Nonce generated by A */
  BWT    aNonceLen;                /**< aNonce의 Bit 길이    */
  BYTE   bNonce[KEHMAC_NONCE_LEN]; /**< Nonce generated by B */
  BWT    bNonceLen;                /**< bNonce의 Bit 길이    */
  void  *macHashAlg; /**< MAC용 hash 알고리즘 descriptor */
  void  *kdfHashAlg; /**< KDF용 hash 알고리즘 descriptor */
} KEHMAC_Context;

/** @ingroup KEA
    @brief KEHMAC_Context를 초기화 하는 함수

    @param ctx [out] 초기화 대상인 KEHMAC_Context의 포인터
    @param aName [in] A의 실체 이름
    @param bName [in] B의 실체 이름
    @param macKey [in]     MAC용 key
    @param macKeyLen [in]  MAC용 key 길이
    @param macHashAlg [in] MAC용 hash 알고리즘 descriptor
    @param kdfKey [in]     KDF용 key 
    @param kdfKeyLen [in]  KDF용 key 길이
    @param kdfHashAlg [in] KDF용 hash 알고리즘 descriptor

    KEHMAC_Context를 초기화한다. KEHMAC을 사용하기 위해서는 
    HEHAMC_Context를 선언해야 하며, 그것을 초기화하는 인터페이스가
    이 함수이다. 다음은 그 예이다.
    
    \code
    KEHMAC_Context ctx;
    
    BYTE macKey[16] = "\x12\x34\x56\x78\x90\x12\x34\x56";
    BWT  macKeyLen = 8;
    BYTE kdfKey[16] = "\x78\x90\x12\x34\x56\x78\x90\x12";
    BWT  kdfKeyLen = 8;
    
    KEHMAC_InitContext(&ctx, "peer1", "peer2", macKey, macKeyLen, MD5, kdfKey, kdfKeyLen, SHA1);
    \endcode

    위의 코드는 MAC용으로 macKey와 MD5 해쉬 함수를 사용하고, 
    KDF용으로 kdfKey와 SHA1 함수를 사용하기 위한 KEHMAC_Context를 만드는 과정을 나타낸다.
*/
LIBSPEC_SP
ERT KEHMAC_InitContext(
    KEHMAC_Context *ctx, char *aName, char *bName, 
    BYTE *macKey, BWT macKeyLen, void *macHashAlg,
    BYTE *kdfKey, BWT kdfKeyLen, void *kdfHashAlg);


/** @ingroup KEA
    @brief B: Make Challenge

    @param bChallenge [out] B가 생성한 Challenge값이 담길 ASNBuf 타입 포인터
    @param ctx [in] KEHMAC_Context의 포인터

    B의 bChallenge를 만드는 함수이다.
*/
LIBSPEC_SP
ERT KEHMAC_B_Challenge(
    ASNBuf **bChallenge, KEHMAC_Context *ctx);


/** @ingroup KEA
    @brief A: Make Response 

    @param aResponse [out] A가 생성한 Response값이 담길 ASNBuf 타입 포인터
    @param bChallenge [in] B가 생성한 Challenge값을 가리키는 ASNBuf 타입 포인터
    @param ctx [in] KEHMAC_Context의 포인터
    @param aExt [in] aResponse 만들기 위해 사용할 부가 정보의 바이트 포인터
    @param aExtLen [in] aResponse 만들기 위해 사용할 부가 정보의 바이트 단위 길이
    
    A의 aResponse를 만드는 함수이다.
*/
LIBSPEC_SP
ERT KEHMAC_A_Response(
    ASNBuf **aResponse, ASNBuf *bChallenge, KEHMAC_Context *ctx,
    BYTE *aExt, BWT aExtLen);


/* @ingroup KEA
   @brief B: Verify Response 

   @param aResponse [out] A가 생성한 Response값을 가리키는 ASNBuf 타입 포인터
   @param ctx [in] KEHMAC_Context의 포인터
   @param aExt [in] A에서 aResponse 만들 때 사용한 부가 정보의 바이트 포인터
   @param aExtLen [in] A에서 aResponse 만들 때 사용한 부가 정보의 바이트 포인터

   A가 보낸 aResponse를 검증하는 함수이다.
*/
LIBSPEC_SP
ERT KEHMAC_B_Verify(ASNBuf *aResponse, KEHMAC_Context *ctx, BYTE *aExt, BWT aExtLen);


/** @ingroup KEA
    @brief B: Make Response

    @param bResponse [out] B가 생성한 Response값이 저장될 ASNBuf 타입 포인터
    @param aResponse [in] A가 생성한 Response값을 가리키는 ASNBuf 타입 포인터
    @param ctx [in] KEHMAC_Context의 포인터
    @param bExt [in] bResponse 만들기 위해 사용할 부가 정보의 바이트 포인터
    @param bExtLen [in] bResponse 만들기 위해 사용할 부가 정보의 바이트 단위 길이

    A의 aResponse를 만드는 함수이다.
*/
LIBSPEC_SP
ERT KEHMAC_B_Response(
    ASNBuf **bResponse, ASNBuf *aResponse, KEHMAC_Context *ctx,
    BYTE *bExt, BWT bExtLen);


/** @ingroup KEA
    @breif A: Verify Response 
    
    @param bResponse [out] B가 생성한 Response값을 가리키는 ASNBuf 타입 포인터
    @param ctx [in] KEHMAC_Context의 포인터
    @param bExt [in] B에서 bResponse 만들 때 사용한 부가 정보의 바이트 포인터
    @param bExtLen [in] B에서 bResponse 만들 때 사용한 부가 정보의 바이트 단위 길이

    B가 보낸 bResponse를 검증하는 함수이다.
*/
LIBSPEC_SP
ERT KEHMAC_A_Verify(
    ASNBuf *bResponse, KEHMAC_Context *ctx, BYTE *bExt, BWT bExtLen);


/** @ingroup KEA
    @brief Key Derivation Function
    
    @param key [out] 생성된 키가 저장될 바이트 포인터
    @param keyLen [in] 키의 길이
    @param ctx [in] KEHMAC_Context의 포인터
    @param ext [in] 키 생성을 위한 부가 정보의 바이트 포인터
    @param extLen [in] 키 생성을 위하 부가 정보의 바이트 단위 길이
    
    인증에 사용된 값을 이용해 키를 생성해 낸다. 이 정보는 ctx에 저장되어 있다.
    이 함수를 사용하기 전에 반드시 Verify 함수를 사용해 인증을 마친 후 
    사용해야한다.
*/
LIBSPEC_SP
ERT KEHMAC_GetKey(BYTE *key, BWT keyLen , KEHMAC_Context *ctx, BYTE *ext, BWT extLen);


#ifdef __cplusplus
}
#endif

#endif /* _KEHMAC_H_ */
